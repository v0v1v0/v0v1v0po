<div class="container">

<table style="width: 100%;"><tr>
<td>allComb</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Finding All Possible Binary Partitions
</h2>

<h3>Description</h3>

<p>These functions are used to find all possible binary partitions.
Finding all combinations require
a classification vector with K &gt; 1 strata.
</p>


<h3>Usage</h3>

<pre><code class="language-R">allComb(x, collapse)
kComb(k)
checkComb(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>

<p>a vector for <code>allComb</code> (can be of any type but treated as factor, must have at least 2 unique values); and a numeric matrix for <code>checkComb</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>collapse</code></td>
<td>

<p>character, what to paste between levels.
Defaults to <code>getOption("ocoptions")$collapse</code>.
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>

<p>numeric, number of levels (strata) in a given classification (K &gt; 1).
</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>kComb</code> returns a contrast matrix corresponding to
all possible binary partitions of the factor with K levels.
Complements are not counted twice, i.e.
(0,0,1,1) is equivalent to (1,1,0,0).
The number of such possible combinations is M = 2^(K - 1) - 1.
</p>
<p><code>allComb</code> takes a classification vector with at least 2 levels
and returns a model matrix with binary partitions.
</p>
<p><code>checkComb</code> checks if combinations are unique and non-complementary
(misfits are returned as attributes). Returns a logical value.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code>opticut</code> for the user interface.
</p>
<p><code>rankComb</code> and <code>lorenz</code>
for alternative partitioning algorithms.
</p>


<h3>Examples</h3>

<pre><code class="language-R">kComb(k = 2)
kComb(k = 3)
kComb(k = 4)

## finding all combinations
(f &lt;- rep(LETTERS[1:4], each=2))
(mc &lt;- allComb(f, collapse = "_"))
## checking for complementary entries
checkComb(mc) # TRUE
## adding complementary entries to the matrix
mc2 &lt;- cbind(z = 1 - mc[,1], mc[,c(1:ncol(mc), 1)])
colnames(mc2) &lt;- 1:ncol(mc2)
mc2
checkComb(mc2) # FALSE
</code></pre>


</div>