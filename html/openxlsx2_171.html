<div class="container">

<table style="width: 100%;"><tr>
<td>wb_to_df</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a data frame from a Workbook</h2>

<h3>Description</h3>

<p>Simple function to create a <code>data.frame</code> from a sheet in workbook. Simple as
in it was simply written down. <code>read_xlsx()</code> and <code>wb_read()</code> are just
internal wrappers of <code>wb_to_df()</code> intended for people coming from other
packages.
</p>


<h3>Usage</h3>

<pre><code class="language-R">wb_to_df(
  file,
  sheet,
  start_row = 1,
  start_col = NULL,
  row_names = FALSE,
  col_names = TRUE,
  skip_empty_rows = FALSE,
  skip_empty_cols = FALSE,
  skip_hidden_rows = FALSE,
  skip_hidden_cols = FALSE,
  rows = NULL,
  cols = NULL,
  detect_dates = TRUE,
  na.strings = "#N/A",
  na.numbers = NA,
  fill_merged_cells = FALSE,
  dims,
  show_formula = FALSE,
  convert = TRUE,
  types,
  named_region,
  keep_attributes = FALSE,
  check_names = FALSE,
  ...
)

read_xlsx(
  file,
  sheet,
  start_row = 1,
  start_col = NULL,
  row_names = FALSE,
  col_names = TRUE,
  skip_empty_rows = FALSE,
  skip_empty_cols = FALSE,
  rows = NULL,
  cols = NULL,
  detect_dates = TRUE,
  named_region,
  na.strings = "#N/A",
  na.numbers = NA,
  fill_merged_cells = FALSE,
  check_names = FALSE,
  ...
)

wb_read(
  file,
  sheet = 1,
  start_row = 1,
  start_col = NULL,
  row_names = FALSE,
  col_names = TRUE,
  skip_empty_rows = FALSE,
  skip_empty_cols = FALSE,
  rows = NULL,
  cols = NULL,
  detect_dates = TRUE,
  named_region,
  na.strings = "NA",
  na.numbers = NA,
  check_names = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>file</code></td>
<td>
<p>An xlsx file, wbWorkbook object or URL to xlsx file.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sheet</code></td>
<td>
<p>Either sheet name or index. When missing the first sheet in the workbook is selected.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_row</code></td>
<td>
<p>first row to begin looking for data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>start_col</code></td>
<td>
<p>first column to begin looking for data.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>row_names</code></td>
<td>
<p>If <code>TRUE</code>, the first col of data will be used as row names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>col_names</code></td>
<td>
<p>If <code>TRUE</code>, the first row of data will be used as column names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip_empty_rows</code></td>
<td>
<p>If <code>TRUE</code>, empty rows are skipped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip_empty_cols</code></td>
<td>
<p>If <code>TRUE</code>, empty columns are skipped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip_hidden_rows</code></td>
<td>
<p>If <code>TRUE</code>, hidden rows are skipped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>skip_hidden_cols</code></td>
<td>
<p>If <code>TRUE</code>, hidden columns are skipped.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rows</code></td>
<td>
<p>A numeric vector specifying which rows in the xlsx file to read.
If <code>NULL</code>, all rows are read.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cols</code></td>
<td>
<p>A numeric vector specifying which columns in the xlsx file to read.
If <code>NULL</code>, all columns are read.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detect_dates</code></td>
<td>
<p>If <code>TRUE</code>, attempt to recognize dates and perform conversion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.strings</code></td>
<td>
<p>A character vector of strings which are to be interpreted as <code>NA</code>.
Blank cells will be returned as <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na.numbers</code></td>
<td>
<p>A numeric vector of digits which are to be interpreted as <code>NA</code>.
Blank cells will be returned as <code>NA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fill_merged_cells</code></td>
<td>
<p>If <code>TRUE</code>, the value in a merged cell is given to all cells within the merge.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>Character string of type "A1:B2" as optional dimensions to be imported.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show_formula</code></td>
<td>
<p>If <code>TRUE</code>, the underlying Excel formulas are shown.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convert</code></td>
<td>
<p>If <code>TRUE</code>, a conversion to dates and numerics is attempted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>types</code></td>
<td>
<p>A named numeric indicating, the type of the data.
Names must match the returned data. See <strong>Details</strong> for more.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>named_region</code></td>
<td>
<p>Character string with a <code>named_region</code> (defined name or table).
If no sheet is selected, the first appearance will be selected. See <code>wb_get_named_regions()</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>keep_attributes</code></td>
<td>
<p>If <code>TRUE</code> additional attributes are returned.
(These are used internally to define a cell type.)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>check_names</code></td>
<td>
<p>If <code>TRUE</code> then the names of the variables in the data frame are checked to ensure that they are syntactically valid variable names.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>additional arguments</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The returned data frame will have named rows matching the rows of the
worksheet. With <code>col_names = FALSE</code> the returned data frame will have
column names matching the columns of the worksheet. Otherwise the first
row is selected as column name.
</p>
<p>Depending if the R package <code>hms</code> is loaded, <code>wb_to_df()</code> returns
<code>hms</code> variables or string variables in the <code>hh:mm:ss</code> format.
</p>
<p>The <code>types</code> argument must be a named numeric.
</p>

<ul>
<li>
<p> 0: character
</p>
</li>
<li>
<p> 1: numeric
</p>
</li>
<li>
<p> 2: date
</p>
</li>
<li>
<p> 3: posixt (datetime)
</p>
</li>
<li>
<p> 4: logical
</p>
</li>
</ul>
<p>If no type is specified, the column types are derived based on all cells
in a column within the selected data range, excluding potential column
names. If <code>keep_attr</code> is <code>TRUE</code>, the derived column types can be inspected
as an attribute of the data frame.
</p>
<p><code>wb_to_df()</code> will not pick up formulas added to a workbook object
via <code>wb_add_formula()</code>. This is because only the formula is written and left
to be evaluated when the file is opened in a spreadsheet software.
Opening, saving and closing the file in a spreadsheet software will resolve
this.
</p>


<h3>See Also</h3>

<p><code>wb_get_named_regions()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">###########################################################################
# numerics, dates, missings, bool and string
example_file &lt;- system.file("extdata", "openxlsx2_example.xlsx", package = "openxlsx2")
wb1 &lt;- wb_load(example_file)

# import workbook
wb_to_df(wb1)

# do not convert first row to column names
wb_to_df(wb1, col_names = FALSE)

# do not try to identify dates in the data
wb_to_df(wb1, detect_dates = FALSE)

# return the underlying Excel formula instead of their values
wb_to_df(wb1, show_formula = TRUE)

# read dimension without colNames
wb_to_df(wb1, dims = "A2:C5", col_names = FALSE)

# read selected cols
wb_to_df(wb1, cols = c("A:B", "G"))

# read selected rows
wb_to_df(wb1, rows = c(2, 4, 6))

# convert characters to numerics and date (logical too?)
wb_to_df(wb1, convert = FALSE)

# erase empty rows from dataset
wb_to_df(wb1, skip_empty_rows = TRUE)

# erase empty columns from dataset
wb_to_df(wb1, skip_empty_cols = TRUE)

# convert first row to rownames
wb_to_df(wb1, sheet = 2, dims = "C6:G9", row_names = TRUE)

# define type of the data.frame
wb_to_df(wb1, cols = c(2, 5), types = c("Var1" = 0, "Var3" = 1))

# start in row 5
wb_to_df(wb1, start_row = 5, col_names = FALSE)

# na string
wb_to_df(wb1, na.strings = "a")

###########################################################################
# Named regions
file_named_region &lt;- system.file("extdata", "namedRegions3.xlsx", package = "openxlsx2")
wb2 &lt;- wb_load(file_named_region)

# read dataset with named_region (returns global first)
wb_to_df(wb2, named_region = "MyRange", col_names = FALSE)

# read named_region from sheet
wb_to_df(wb2, named_region = "MyRange", sheet = 4, col_names = FALSE)

# read_xlsx() and wb_read()
example_file &lt;- system.file("extdata", "openxlsx2_example.xlsx", package = "openxlsx2")
read_xlsx(file = example_file)
df1 &lt;- wb_read(file = example_file, sheet = 1)
df2 &lt;- wb_read(file = example_file, sheet = 1, rows = c(1, 3, 5), cols = 1:3)
</code></pre>


</div>