<div class="container">

<table style="width: 100%;"><tr>
<td>hjn</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compact R Implementation of Hooke and Jeeves Pattern Search Optimization</h2>

<h3>Description</h3>

<p>The purpose of <code>hjn</code> is to minimize an unconstrained or bounds
(box) and mask constrained function 
of several parameters by a Hooke and Jeeves pattern search. This 
didactic code is
entirely in R to allow users to explore and understand the method. It also
allows bounds (or box) constraints and masks (equality constraints) to be
imposed on parameters. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">   hjn(par, fn, lower=-Inf, upper=Inf, bdmsk=NULL, control = list(trace=0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>A numeric vector of starting estimates.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fn</code></td>
<td>
<p>A function that returns the value of the objective at the
supplied set of parameters <code>par</code> using auxiliary data in ....
The first argument of <code>fn</code> must be <code>par</code>. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lower</code></td>
<td>
<p>A vector of lower bounds on the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>upper</code></td>
<td>
<p>A vector of upper bounds on the parameters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bdmsk</code></td>
<td>
<p>An indicator vector, having 1 for each parameter that is "free" or
unconstrained, and 0 for any parameter that is fixed or MASKED for the
duration of the optimization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>control</code></td>
<td>

<p>An optional list of control settings.  
</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Further arguments to be passed to <code>fn</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Functions <code>fn</code> must return a numeric value.
</p>
<p>The <code>control</code> argument is a list.
</p>

<dl>
<dt>maxfeval</dt>
<dd>
<p>A limit on the number of function evaluations used in the search.</p>
</dd>
<dt>trace</dt>
<dd>
<p>Set 0 (default) for no output, &gt;0 for trace output
(larger values imply more output).</p>
</dd>
<dt>eps</dt>
<dd>
<p>Tolerance used to calculate numerical gradients. Default is 1.0E-7. See 
source code for <code>hjn</code> for details of application.</p>
</dd>
<dt><code>dowarn</code></dt>
<dd>
<p>= TRUE if we want warnings generated by optimx. Default is 
TRUE.</p>
</dd>
<dt><code>tol</code></dt>
<dd>
<p>Tolerance used in testing the size of the pattern search step.</p>
</dd>
</dl>
<p>Note that the control <code>maximize</code> should NOT be used. 
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>par</code></td>
<td>
<p>The best set of parameters found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>value</code></td>
<td>
<p>The value of the objective at the best set of parameters found.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>counts</code></td>
<td>
<p>A two-element integer vector giving the number of calls to
'fn' and 'gr' respectively. This excludes those calls needed
to compute the Hessian, if requested, and any calls to 'fn'
to compute a finite-difference approximation to the gradient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>convergence</code></td>
<td>
<p>An integer code. 
'0' indicates successful convergence.
'1' indicates that the function evaluation count 'maxfeval' was reached.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>message</code></td>
<td>
<p>A character string giving any additional information returned
by the optimizer, or 'NULL'.</p>
</td>
</tr>
</table>
<h3>References</h3>

<p>Nash JC (1979). Compact Numerical Methods for Computers: Linear 
Algebra and Function Minimisation. Adam Hilger, Bristol. Second 
Edition, 1990, Bristol: Institute of Physics Publications.
</p>


<h3>See Also</h3>

<p><code>optim</code></p>


<h3>Examples</h3>

<pre><code class="language-R">#####################
## Rosenbrock Banana function
fr &lt;- function(x) {
    x1 &lt;- x[1]
    x2 &lt;- x[2]
    100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}

ansrosenbrock0 &lt;- hjn(fn=fr, par=c(1,2), control=list(maxfeval=2000, trace=0))
print(ansrosenbrock0) # use print to allow copy to separate file that 

#    can be called using source()
#####################
genrose.f&lt;- function(x, gs=NULL){ # objective function
## One generalization of the Rosenbrock banana valley function (n parameters)
	n &lt;- length(x)
        if(is.null(gs)) { gs=100.0 }
	fval&lt;-1.0 + sum (gs*(x[1:(n-1)]^2 - x[2:n])^2 + (x[2:n] - 1)^2)
        return(fval)
}

xx&lt;-rep(pi,10)
lower&lt;-NULL
upper&lt;-NULL
bdmsk&lt;-NULL

cat("timings B vs U\n")
lo&lt;-rep(-100,10)
up&lt;-rep(100,10)
bdmsk&lt;-rep(1,10)
tb&lt;-system.time(ab&lt;-hjn(xx,genrose.f, lower=lo, upper=up,
          bdmsk=bdmsk, control=list(trace=0, maxfeval=2000)))[1]
tu&lt;-system.time(au&lt;-hjn(xx,genrose.f, control=list(maxfeval=2000, trace=0)))[1]
cat("times U=",tu,"   B=",tb,"\n")
cat("solution hjnu\n")
print(au)
cat("solution hjnb\n")
print(ab)
cat("diff fu-fb=",au$value-ab$value,"\n")
cat("max abs parameter diff = ", max(abs(au$par-ab$par)),"\n")

######### One dimension test
sqtst&lt;-function(xx) {
   res&lt;-sum((xx-2)*(xx-2))
}

nn&lt;-1
startx&lt;-rep(0,nn)
onepar&lt;-hjn(startx,sqtst,control=list(trace=1)) 
print(onepar)
</code></pre>


</div>