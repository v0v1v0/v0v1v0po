<div class="container">

<table style="width: 100%;"><tr>
<td>ordinalNetTune</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Uses K-fold cross validation to obtain out-of-sample log-likelihood and
misclassification rates for a sequence of lambda values.</h2>

<h3>Description</h3>

<p>The data is divided into K folds. <code>ordinalNet</code> is fit <code class="reqn">K</code> times (<code>K=nFolds</code>),
each time leaving out one fold as a test set. The same sequence of lambda values is used
each time. The out-of-sample log-likelihood, misclassification rate, Brier score,
and percentage of deviance explained are obtained for each lambda value from
the held out test set. It is up to the user to determine how to tune the model
using this information.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ordinalNetTune(
  x,
  y,
  lambdaVals = NULL,
  folds = NULL,
  nFolds = 5,
  printProgress = TRUE,
  warn = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Covariate matrix.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>Response variable. Can be a factor, ordered factor, or a matrix
where each row is a multinomial vector of counts. A weighted fit can be obtained
using the matrix option, since the row sums are essentially observation weights.
Non-integer matrix entries are allowed.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambdaVals</code></td>
<td>
<p>An optional user-specified lambda sequence (vector). If <code>NULL</code>,
a sequence will be generated using the model fit to the full training data.
This default sequence is based on <code>nLambda</code> and <code>lambdaMinRatio</code>,
which can be passed as additional arguments (otherwise <code>ordinalNet</code> default
values are used). The maximum lambda is the smallest value that sets all penalized
coefficients to zero, and the minimum lambda is the maximum value multiplied
by the factor <code>lambdaMinRatio</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>folds</code></td>
<td>
<p>An optional list, where each element is a vector of row indices
corresponding to a different cross validation fold. Indices correspond to rows
of the <code>x</code> matrix. Each index number should be used in exactly one fold.
If <code>NULL</code>, the data will be randomly divided into equal-sized partitions.
It is recommended to use <code>set.seed</code> before calling this function to make
results reproducible.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nFolds</code></td>
<td>
<p>Numer of cross validation folds. Only used if <code>folds=NULL</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>printProgress</code></td>
<td>
<p>Logical. If <code>TRUE</code> the fitting progress is printed
to the terminal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>warn</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the following warning message is displayed
when fitting a cumulative probability model with <code>nonparallelTerms=TRUE</code>
(i.e. nonparallel or semi-parallel model).
"Warning message: For out-of-sample data, the cumulative probability model
with nonparallelTerms=TRUE may predict cumulative probabilities that are not
monotone increasing."
The warning is displayed by default, but the user may wish to disable it.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments (besides <code>x</code>, <code>y</code>, <code>lambdaVals</code>, and <code>warn</code>)
passed to <code>ordinalNet</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>


<ul>
<li>
<p> The fold partition splits can be passed by the user via the <code>folds</code>
argument. By default, the data are randomly divided into equally-sized partitions.
The <code>set.seed</code> function should be called prior to <code>ordinalNetCV</code> for reproducibility.
</p>
</li>
<li>
<p> A sequence of lambda values can be passed by the user via the
<code>lambdaVals</code> argument. By default, the sequence is generated by first
fitting the model to the full data set (this sequence is determined by the
<code>nLambda</code> and <code>lambdaMinRatio</code> arguments of <code>ordinalNet</code>).
</p>
</li>
<li>
<p> The <code>standardize</code> argument of <code>ordinalNet</code> can be modified through
the additional arguments (...). If <code>standardize=TRUE</code>, then the data are scaled
within each cross validation fold. This is done because scaling is part of
the statistical procedure and should be repeated each time the procedure is applied.
</p>
</li>
</ul>
<h3>Value</h3>

<p>An S3 object of class "ordinalNetTune", which contains the following:
</p>

<dl>
<dt>loglik</dt>
<dd>
<p>Matrix of out-of-sample log-likelihood values.
Each row corresponds to a lambda value, and each column corresponds to a fold.</p>
</dd>
<dt>misclass</dt>
<dd>
<p>Matrix of out-of-sample misclassificaton rates.
Each row corresponds to a lambda value, and each column corresponds to a fold.</p>
</dd>
<dt>brier</dt>
<dd>
<p>Matrix of out-of-sample Brier scores. Each row corresponds
to a lambda value, and each column corresponds to a fold.</p>
</dd>
<dt>devPct</dt>
<dd>
<p>Matrix of out-of-sample percentages of deviance explained.
Each row corresponds to a lambda value, and each column corresponds to a fold.</p>
</dd>
<dt>lambdaVals</dt>
<dd>
<p>The sequence of lambda values used for all cross validation folds.</p>
</dd>
<dt>folds</dt>
<dd>
<p>A list containing the index numbers of each fold.</p>
</dd>
<dt>fit</dt>
<dd>
<p>An object of class "ordinalNet", resulting from fitting
<code>ordinalNet</code> to the entire dataset.</p>
</dd>
</dl>
<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
# Simulate x as independent standard normal
# Simulate y|x from a parallel cumulative logit (proportional odds) model
set.seed(1)
n &lt;- 50
intercepts &lt;- c(-1, 1)
beta &lt;- c(1, 1, 0, 0, 0)
ncat &lt;- length(intercepts) + 1  # number of response categories
p &lt;- length(beta)  # number of covariates
x &lt;- matrix(rnorm(n*p), ncol=p)  # n x p covariate matrix
eta &lt;- c(x %*% beta) + matrix(intercepts, nrow=n, ncol=ncat-1, byrow=TRUE)
invlogit &lt;- function(x) 1 / (1+exp(-x))
cumprob &lt;- t(apply(eta, 1, invlogit))
prob &lt;- cbind(cumprob, 1) - cbind(0, cumprob)
yint &lt;- apply(prob, 1, function(p) sample(1:ncat, size=1, prob=p))
y &lt;- as.factor(yint)

# Fit parallel cumulative logit model; select lambda by cross validation
tunefit &lt;- ordinalNetTune(x, y)
summary(tunefit)
plot(tunefit)
bestLambdaIndex &lt;- which.max(rowMeans(tunefit$loglik))
coef(tunefit$fit, whichLambda=bestLambdaIndex, matrix=TRUE)
predict(tunefit$fit, whichLambda=bestLambdaIndex)

## End(Not run)

</code></pre>


</div>