<div class="container">

<table style="width: 100%;"><tr>
<td>mxFitFunctionMultigroup</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create a fit function used to fit multiple-group models</h2>

<h3>Description</h3>

<p><code>mxFitFunctionMultigroup</code> creates a fit function consisting of the sum of the fit statistics
from a list of submodels provided. Thus, it aggregates fit statistics from multiple submodels.
</p>
<p>This total provides the optimization target for fitting a multi-group model.
</p>
<p>In addition to being more compact and readable, using <code>mxFitFunctionMultigroup</code> has
additional side effects which are valuable for multi-group modeling.
</p>
<p>First, it aggregates analytic derivative calculations.
</p>
<p>Second, it allows <code>mxRefModels</code> to compute saturated models for raw data, as this function can learn which are the constituent submodels.
</p>
<p>Third, and finally, it allows <code>mxCheckIdentification</code> to evaluate the local identification of the multigroup model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">mxFitFunctionMultigroup(groups, ..., verbose = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>groups</code></td>
<td>
<p>vector of submodel names (strings)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Not used. Forces subsequent arguments to be specified by name.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>the level of debugging output</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Conceptually, <code>mxFitFunctionMultigroup</code> is equivalent to summing the subModel objectives in an mxAlgebra,
and using an mxFitFunctionAlgebra to optimize the model based on this summed likelihood.
</p>
<p>e.g. this 1-line call to mxFitFunctionMultigroup:
</p>
<p><code>mxFitFunctionMultigroup(c("model1", "model2"))</code>
</p>
<p>is equivalent to the following pair of statements:
</p>
<p><code>mxAlgebra(name = "myAlgebra", model1.objective + model2.objective)</code>
</p>
<p><code>mxFitFunctionAlgebra("myAlgebra")</code>
</p>
<p><em>Note</em>: If needed, you can refer to the algebra generated by <code>mxFitFunctionMultigroup</code> as:
</p>
<p><code>modelName.fitfunction</code>
</p>
<p>Where "modelName" is the name of the container or supermodel.
</p>


<h3>See Also</h3>

<p>Other fit functions:
<code>mxFitFunctionML</code>,
<code>mxFitFunctionWLS</code>, <code>mxFitFunctionAlgebra</code>,
<code>mxFitFunctionGREML</code>, <code>mxFitFunctionR</code>,
<code>mxFitFunctionRow</code>
</p>
<p>More information about the OpenMx package may be found here.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#------------------------------------------------
# Brief non-running example
require("OpenMx")
mxFitFunctionMultigroup(c("model1", "model2")) # names of sub-models to be jointly optimised



# ===========================================
# = Longer, fully featured, running example =
# ===========================================

# Create and fit a model using mxMatrix, mxExpectationRAM, mxFitFunctionML,
# and mxFitFunctionMultigroup.
# The model is multiple group regression.
# Only the residual variances are allowed to differ across groups.


library(OpenMx)

# Simulate some data

# Group 1
N1 = 100
x = rnorm(N1, mean= 0, sd= 1)
y = 0.5*x + rnorm(N1, mean= 0, sd= 1)
ds1 &lt;- data.frame(x, y)
dsNames &lt;- names(ds1)

# Group 2: y has greater variance; x &amp; y slightly lower correlation...
N2= 150
x= rnorm(N2, mean= 0, sd= 1)
y= 0.5*x + rnorm(N2, mean= 0, sd= sqrt(1.5))
ds2 &lt;- data.frame(x, y)


# Define the matrices (A matrix implementation of 2 RAM models)

I &lt;- mxMatrix(name="I", type="Iden", nrow=2, ncol=2)
M &lt;- mxMatrix(name = "M", type = "Full", nrow = 1, ncol = 2, values=0,
              free=TRUE, labels=c("Mean_x", "Mean_y"))
# A matrix containing a path "b" of x on y
A &lt;- mxMatrix(name = "A", type = "Full", nrow = 2, ncol = 2, values=c(0,1,0,0),
              free=c(FALSE,TRUE,FALSE,FALSE), labels=c(NA, "b", NA, NA))

S1 &lt;- mxMatrix(name = "S", type = "Diag", nrow = 2, ncol = 2, values=1,
              free=TRUE, labels=c("Var_x", "Resid_y_group1"))
S2 &lt;- mxMatrix(name = "S", type = "Diag", nrow = 2, ncol = 2, values=1,
              free=TRUE, labels=c("Var_x", "Resid_y_group2"))

# Define the expectation
expect &lt;- mxExpectationRAM('A', 'S', 'I', 'M', dimnames= dsNames)


# Choose a fit function
fitFunction &lt;- mxFitFunctionML(rowDiagnostics=TRUE)
# Also return row likelihoods (the fit function value is still 1x1)

# Multiple-group fit function sums the model likelihoods
# from its component models
mgFitFun &lt;- mxFitFunctionMultigroup(c('g1model', 'g2model'))


# Define model 1 and model 2
m1 = mxModel(model="g1model",
	M, S1, A, I, expect, fitFunction,
    mxData(cov(ds1), type="cov", numObs=N1, means=colMeans(ds1))
)
m2 = mxModel(model="g2model",
	M, S2, A, I, expect, fitFunction,
    mxData(cov(ds2), type="cov", numObs=N2, means=colMeans(ds2))
)

mg &lt;- mxModel(model='multipleGroup', m1, m2, mgFitFun)
# note!: Paths with the same name in both submodels are
# constrained to the same value across models. i.e.,
# b has only 1 value, as does Var_x. But Resid_y can take distinct
# values in the two groups.

# Fit the model and print a summary
mg &lt;- mxRun(mg)
summary(mg)

# Examine fit function results
# Fit in -2lnL units)
mxEval(fitfunction, mg)

# Fit function results for each submodel:
mxEval(g1model.fitfunction, mg)
mxEval(g2model.fitfunction, mg)

mg2 = omxSetParameters(mg,
  labels = c("Resid_y_group1", "Resid_y_group2"),
  newlabels = "Resid_y", name = "equated")
mg2 = omxAssignFirstParameters(mg2)
mg2 = mxRun(mg2)

mxCompare(mg, mg2)
# ouch... that was a significant loss in fit: the residuals definately are larger in group2!

</code></pre>


</div>